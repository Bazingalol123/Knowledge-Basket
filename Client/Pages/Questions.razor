@page "/GamesList/QuestionsToEdit/{id:int}"
@using template.Shared.Models.Classes
@inject HttpClient Http
@using template.Client.Components
@inject NavigationManager Nav
@inject IJSRuntime JS




<link href="css/GameListDesign.css" rel="stylesheet" />
<ButtonComponent ButtonColor="#36697C" ButtonText="למשחקים שלי"
                 Width="180px" type="button" top="110px" right="1280px" Position="fixed" OnClick="SwitchToSaveModal" direction="ltr" display="flex" justifyContent="center" alignItems="center"><img src="images/reply.svg" style="margin-left:5px;" /></ButtonComponent>
<div id="sign" style="display: flex;">
    <div class="sign-image-container">
        <img src="images/board-png-8.png" class="headerBoard" />
        <div class="text-overlay">
            <p>עריכת שאלות</p>
        </div>
        <div id="gameNameInQuestions">
            <p>@gameToEdit.GameName</p>
            <p>|</p>
            @if (gameToEdit.questionTime == int.MaxValue)
            {
                <p>אין הגבלת זמן</p>
            }
            else
            {
                <p>@gameToEdit.questionTime.ToString() שניות לשאלה</p>
            }

            <button class="tableButtons" @onclick="ShowModal2">
                <i class="bi bi-gear-wide"></i>
            </button>
        </div>
    </div>
</div>



<PopUpComponent IsVisible="showModal2" OnClose="HideModal2">
    <div style="bottom:30px;">
        <p class="newGameHeader">הגדרות משחק</p>
        <EditForm Model="gameToEdit" OnValidSubmit="HideModal2" id="EditGameForm">
            <DataAnnotationsValidator />
            <p style="font-size:24px;">שם המשחק</p>
            <CustomInputText class="textInForm" @bind-Value="gameToEdit.GameName" placeholder=" שם המשחק" />
            <div style="height:20px;">
                <ValidationMessage For="@(() => gameToEdit.GameName)" style="font-size:17px;" />
            </div>
            <div>
                <p style="font-size:24px;">זמן לשאלה</p>
                <InputRadioGroup @bind-Value="gameToEdit.questionTime" class="radio-group">
                    <div style="display:inline-block">
                        <InputRadio Value="20" class="circle-radio" @attributes="@(new Dictionary<string, object> { { "data-value", "20" } })" />
                    </div>
                    <div style="display:inline-block">
                        <InputRadio Value="30" class="circle-radio" @attributes="@(new Dictionary<string, object> { { "data-value", "30" } })" />
                    </div>
                    <div style="display:inline-block">
                        <InputRadio Value="60" class="circle-radio" @attributes="@(new Dictionary<string, object> { { "data-value", "60" } })" />
                    </div>
                    <div style="display:inline-block">
                        <InputRadio Value="90" class="circle-radio" @attributes="@(new Dictionary<string, object> { { "data-value", "90" } })" />
                    </div>
                    <div style="display:inline-block;">
                        <InputRadio Value="@int.MaxValue" class="circle-radio" @attributes="@(new Dictionary<string, object> { { "data-value", "ללא הגבלת זמן" } })" id="lastButton" />
                    </div>
                </InputRadioGroup>
                <ValidationMessage For="@(() => gameToEdit.questionTime)" />
            </div>
            <div style="display: flex; justify-content: flex-end; width:60em; position: relative; top:25px; left: 12em;">
                <ButtonComponent ButtonText="ביטול" ButtonColor="white" TextColor="black" OnClick="HideModal2" Width="140px" />
                @if (MyGamesList != null)
                {
                    var originalGame = MyGamesList.FirstOrDefault(g => g.ID == gameToEdit.ID);
                    if (originalGame != null)
                    {
                        if (gameToEdit.GameName == originalGame.GameName && gameToEdit.questionTime == originalGame.questionTime)
                        {
                            <ButtonComponent ButtonText="שמירת שינויים" ButtonColor="#EEC383" TextColor="black" Disabled="true" Width="150px" />
                        }
                        else
                        {
                            <ButtonComponent ButtonText="שמירת שינויים" ButtonColor="orange" TextColor="black" OnClick="EditGame" Width="150px" />
                        }
                    }
                }
            </div>
        </EditForm>
    </div>
</PopUpComponent>

<PopUpComponent IsVisible="showModalDeleteQuestion" OnClose="ShowHideModalDeleteQuestion">
    <p class="newGameHeader">מחיקת שאלה</p>
    <p class="pop-up-text">לחיצה על כפתור מחיקה תמחק את השאלה <b>"@questionsEdit.content" </b>לצמיתות.</p>
    <p class="pop-up-text">האם ברצונך למחוק את השאלה?</p>
    <div class="pop-up-buttons">
        <ButtonComponent ButtonText="ביטול" ButtonColor="white" TextColor="black" OnClick="ShowHideModalDeleteQuestion" Width="140px" />
        <ButtonComponent ButtonText="מחיקת שאלה" ButtonColor="orange" TextColor="black" OnClick="DeleteQuestion" Width="140px" />
    </div>
</PopUpComponent>

<PopUpComponent IsVisible="showModalDeleteAnswer" OnClose="ShowHideModalDeleteAnswer">
    <p class="newGameHeader">מחיקת תשובה</p>
    <p class="pop-up-text">לחיצה על כפתור מחיקה תמחק את התשובה לצמיתות.</p>
    <p class="pop-up-text">האם ברצונך למחוק את התשובה?</p>
    <div class="pop-up-buttons">
        <ButtonComponent ButtonText="ביטול" ButtonColor="white" TextColor="black" OnClick="ShowHideModalDeleteAnswer" Width="140px" />
        <ButtonComponent ButtonText="מחיקת תשובה" ButtonColor="orange" TextColor="black" OnClick="DeleteConfirmedAnswer" Width="150px" />
    </div>
</PopUpComponent>



<PopUpComponent IsVisible="saveIfChanges" OnClose="SwitchToSaveModal">
    <p class="newGameHeader">חזרה למשחקים שלי</p>
    <p class="pop-up-text">בלחיצה על המשך השינויים שביצעת לא יישמרו.</p>
    <p class="pop-up-text">האם ברצונך לעבור למשחקים שלי?</p>
    <div class="pop-up-buttons">
        <ButtonComponent ButtonText="ביטול" ButtonColor="white" TextColor="black" OnClick="SwitchToSaveModal" Width="140px" />
        <ButtonComponent ButtonText="המשך" ButtonColor="orange" TextColor="black" OnClick="GoBackToGames" Width="150px" />
    </div>
</PopUpComponent>

<PopUpComponent IsVisible="showSaveChangesModal" OnClose="HideSaveChangesModal">
    <p class="newGameHeader">שינוי שאלה</p>
    <p class="pop-up-text">בלחיצה על המשך השינויים שביצעת לא יישמרו.</p>
    <p class="pop-up-text">האם ברצונך להמשיך?</p>
    <div class="pop-up-buttons">
        <ButtonComponent ButtonText="ביטול" ButtonColor="white" TextColor="black" OnClick="HideSaveChangesModal" Width="140px" />
        <ButtonComponent ButtonText="המשך" ButtonColor="orange" TextColor="black" OnClick="ConfirmLoadAnswers" Width="150px" />
    </div>
</PopUpComponent>

<PopUpComponent IsVisible="showSaveChangesModalForRemove" OnClose="HideSaveChangesModalForRemove">
    <p class="newGameHeader">איפוס שדות</p>
    <p class="pop-up-text">איפוס שדות יגרום למחיקת כל התוכן שהוזן עד כה בשאלה ובמסיחים.</p>
    <p class="pop-up-text">האם ברצונך להמשיך?</p>
    <div class="pop-up-buttons">
        <ButtonComponent ButtonText="ביטול" ButtonColor="white" TextColor="black" OnClick="HideSaveChangesModalForRemove" Width="140px" />
        <ButtonComponent ButtonText="איפוס שדות" ButtonColor="orange" TextColor="black" OnClick="ConfirmRemoveSelection" Width="150px" />
    </div>
</PopUpComponent>

<PopUpComponent IsVisible="largePhotoModalShow" OnClose="EnlargeImage">
    <div class="modal-enlarge-picture-content">
        <img src="@imgToShow" class="enlarged-image" @onclick="EnlargeImage" />
    </div>
</PopUpComponent>

<PopUpComponent IsVisible="showToggleConfirmModal" OnClose="CancelToggle">
    <p class="newGameHeader">החלפת @(newValueForToggle ? "טקסט" : "תמונה")  ל@(!newValueForToggle ? "טקסט" : "תמונה")</p>
    <p style="color: white; font-size: 18px; position:relative; right:150px; height:10px;">
        שינוי זה יגרום למחיקת @(newValueForToggle ? "הטקסט" : "התמונה"). ברצונך להמשיך עם פעולה זו?
    </p>
    <div class="pop-up-buttons">
        <ButtonComponent ButtonText="ביטול" ButtonColor="white" TextColor="black" OnClick="CancelToggle" Width="140px" />
        <ButtonComponent ButtonText="החלפה" ButtonColor="orange" TextColor="black" OnClick="ConfirmToggle" Width="150px" />
    </div>
</PopUpComponent>






@if (isLoading)
{
    <p>Loading...</p>
}
else if (questions.Count < 0)
{
    @*<p class="text-danger">@errorMessage</p>*@
}
else
{
    <div id="queAnsDiv">
        <div id="questionsList">
            <div style="position: relative; z-index: 1; bottom:32px;left: 31px;background-color:#739477; height:30px; width:35em; border-radius:10px 10px 0px 0px; padding: 1px;">
                <p style="position: relative; right: 20px;color:white;font-size:18px; bottom:10px;">רשימת שאלות</p>
                <p style="position: relative; right: 140px;bottom:45px;color:white;font-size:12px; ">(@questions.Count/@maxQuestions)</p>
                <div class="question-condition">
                    @if (questions.Count >= 10)
                    {
                        <img src="images/checkgreen.svg" alt="icon" style="position:relative; left:5px;" />
                    }
                    else
                    {
                        <img src="images/cancelred.svg" alt="icon" style="position:relative; left:5px;" />
                    }

                    <p style="color:white;font-size:14px;">לפחות @minQuestions שאלות</p>
                </div>
            </div>
            <div id="questionsSheet">
                @if (questions.Count <= 0)
                {
                    <div class="question-marks-container">
                        <img src="images/questionMarks-8.png" id="question-marks">
                        <p>עדיין לא נוצרו שאלות...</p>
                    </div>
                }
                else
                {
                    @foreach (var question in questions)
                    {
                        <div id="questions">
                            <div id="eachQuestion" @onclick="() => LoadAnswers(question.id)" class="@(selectedQuestionId == question.id ? "yes-active-question" : "not-active")">
                                @if (selectedQuestionId == question.id)
                                {
                                    <button @onclick="@(e => ShowHideModalDeleteQuestion())" class="delete-icon">
                                        <i class="bi bi-trash-fill"></i>
                                    </button>
                                }
                                <div class="question-content">
                                    <img src="images/ball.png" alt="icon" class="question-icon" />
                                    @question.content
                                </div>
                            </div>
                        </div>
                    }
                }
            </div>
        </div>
        @if (questions.Count == 30 && !isQuestionSelected)
        {

            <div id="maximum-question-screen">
                <div id="basket-container">
                    <img src="images/basket-for-site.png" />
                    <p style="width:100px; height:200px; text-align:center; position:relative;bottom:310px; left:120px;">
                        נוצרו 30 שאלות לא ניתן ליצור עוד שאלות!
                        אפשר לערוך או למחוק שאלות קיימות מהרשימה.
                    </p>
                </div>
            </div>
        }
        else
        {


            <div id="answersContainer">
                <div id="answersList">
                    <EditForm EditContext="_editContext" OnValidSubmit="SaveChanges" OnInvalidSubmit="HandleInvalidSubmit" style="height:420px; position:relative; bottom:15px;">
                        <DataAnnotationsValidator />
@*                        <ValidationSummary style="font-size:14px; position:fixed; top:580px; left: 100px;" />
*@                        <ToolTip Text="בשאלה ניתן להזין טקסט (בין 2-60 תווים) ולצרף תמונה" right="50px" bottom="-35px" width="190px">
                            <img src="images/tooltip.svg" style="height:18px; width: 18px;" />
                        </ToolTip>

                        <p style="font-size: 18px;">שאלה</p>
                        <div style="display:flex; position: relative; width:600px; align-items:center; bottom:20px;">
                            <label></label>
                            <CustomInputText id="questionText" @bind-Value="questionsEdit.content" maxLength="60" midLength="15" minLength="2" OnInputChanged="MarkChangedStatus" />
                            @*<ValidationMessage For="@(() => questionsEdit.content)" style="font-size:14px; position:fixed; top:620px; left: 100px;" />*@
                            <div class="questionImage">
                                @if (string.IsNullOrEmpty(questionsEdit.image))
                                {
                                    <div class="file-upload-container">
                                        <label for="fileInput" class="custom-file-upload"></label>
                                        <InputFile id="fileInput" OnChange="UploadFile" style="display:none;" />
                                    </div>
                                }
                                else
                                {
                                    <div class="image-container">
                                        <img src="@questionsEdit.image" alt="Question Image" @onclick="() => ShowImageModal(questionsEdit.image)" id="question-image" />
                                        <img src="images/frame-inspect.svg" class="magnifying-glass" />
                                    </div>
                                    <button class="tableButtons" @onclick="MarkImageForDeletion"><i class="bi bi-trash-fill" /></button>
                                }

                            </div>
                        </div>
                        <ToolTip Text="שאלה יכולה להכיל 2-6 מסיחים, בתוכם טקסט (עד 40 תווים) או תמונה" right="65px" bottom="25px" width="190px"> <img src="images/tooltip.svg" style="height:18px; width: 18px;" /></ToolTip>
                        <p style="font-size: 18px; display: inline; position:relative; bottom:40px;">תשובות</p>
                        <div id="answerInputContainer">
                            @foreach (var answer in questionsEdit.AnswerList)
                            {
                                var guid = Guid.NewGuid().ToString();
                                <div class="mb-3">
                                    @if (questionsEdit.AnswerList.Count > 2)
                                    {
                                        <button type="button" class="tableButtons" style="position: relative; bottom:70px;width:20px;" @onclick="() => ConfirmDeleteAnswer(answer)">
                                            <i class="bi bi-trash-fill" />
                                        </button>
                                    }
                                    else
                                    {
                                        @*<div style="width:20px; height:20px; position: relative; bottom:70px;"></div>*@
                                    }

                                    @if (answer.IsImageAnswer == false)
                                    {


                                        <CustomInputTextArea class="answers" @bind-Value="answer.textContent" @onchange="MarkChangedStatus" MaxLength="40" placeholder ="הזן טקסט"></CustomInputTextArea>


                                    }
                                    else
                                    {

                                        @if (string.IsNullOrEmpty(answer.imageContentWithoutText))
                                        {
                                            <label for="@GenerateAnswerFileInputId(answer)" class="answersImageExist" id="answer-image-upload"></label>
                                            <InputFile id="@GenerateAnswerFileInputId(answer)" OnChange="async e => await UploadFileForAnswer(e, answer)" style=" display:none;" />
                                        }
                                        else
                                        {
                                            <div class="answersImageExist">
                                                <div class="image-container">
                                                    <img src="@answer.imageContentWithoutText" alt="Answer Image" @onclick="() => ShowImageModal(answer.imageContentWithoutText)" sstyle="object-fit: contain; object-position: center; width: 60px; height: auto;max-width: 60px; max-height: 72.5px;" />
                                                    <img src="images/frame-inspect.svg" class="magnifying-glass" id="magnifying-in-answer" />

                                                </div>
                                            </div>
                                        }

                                    }

                                    <div class="label-is-correct">
                                        <InputCheckbox @bind-Value="answer.IsCorrect" @onchange="() => { UpdateCheckboxState(answer); MarkChangedStatus(); }" disabled="@IsCheckboxDisabled(answer)" />
                                        <label></label>
                                    </div>

                                    <div class="toggle-container">
                                        <span>תמונה</span>
                                        <label class="switch" for="toggleAddType_@guid">
                                            <input type="checkbox" id="toggleAddType_@guid" data-guid="@guid"
                                            @onchange="async (e) => { await ToggleAddType(e, answer, guid); }"
                                                   checked="@answer.IsImageAnswer" />
                                            <span class="slider round"></span>
                                        </label>
                                        <span>טקסט</span>
                                    </div>
                                </div>
                            }

                            @if (questionsEdit.AnswerList.Count < 6)
                            {
                                <div>
                                    <button class="answers" id="textAreaLookAlike" type="button" @onclick="() => { AddTemporaryAnswer(); MarkChangedStatus(); }"></button>
                                </div>
                            }
                        </div>
                        <p style="color: green;
    font-size: 14px;
    font-weight: bold;
    position: absolute;
    right: 635px;
    top: 445px;
    width: 100px;">@_message</p>

                        @if (isNewQuestion && !isQuestionSelected &&
                       (string.IsNullOrWhiteSpace(questionsEdit.content) ||
                       questionsEdit.AnswerList.Any(a => string.IsNullOrWhiteSpace(a.textContent) && string.IsNullOrEmpty(a.imageContentWithoutText)) ||
                       !questionsEdit.AnswerList.Any(a => a.IsCorrect)))
                        {
                            @if (questions.Count == 0)
                            {
                                <div class="sticky-but-newque">
                                    <div class="tooltip-button-wrapper">
                                        <ToolTip Text="איפוס שדות יאפס את כל התוכן שהוזן בשאלה ובתשובות" bottom="0px" width="120px">
                                            <ButtonComponent ButtonText="איפוס שדות" ButtonColor="#F6F6F3" TextColor="black" left="120px" Height="40px" Width="140px" OnClick="RemoveSelection" Disabled="true" type="button" />
                                        </ToolTip>
                                    </div>
                                    <div class="tooltip-button-wrapper">
                                        <ToolTip Text="לאחר שמירת השאלה המסך יתאפס ליצירת שאלה חדשה" bottom="0px" width="140px">
                                            <ButtonComponent ButtonText="שמירת שאלה" ButtonColor="#EEC383" TextColor="black" Width="140px" Disabled="true" MarginRight="30px" />
                                        </ToolTip>
                                    </div>
                                </div>
                            }
                            else
                            {
                                <div class="sticky-but-newque">
                                    <ButtonComponent ButtonText="איפוס שדות" ButtonColor="#F6F6F3" TextColor="black" left="120px" Height="40px" Width="140px" OnClick="RemoveSelection" type="button" Disabled="true" />
                                    <ButtonComponent ButtonText="שמירת שאלה" ButtonColor="#EEC383" TextColor="black" Width="140px" Disabled="true" />
                                </div>
                            }
                        }

                        else if (isNewQuestion && !isQuestionSelected && questions.Count < maxQuestions)
                        {
                            <div class="sticky-but-newque">
                                <ButtonComponent ButtonText="איפוס שדות" ButtonColor="white" TextColor="black" Width="140px" left="120px" Height="40px" OnClick="RemoveSelection" type="button" />
                                <ButtonComponent ButtonText="שמירת שאלה" ButtonColor="orange" TextColor="black" Width="140px" type="submit" />
                            </div>
                        }
                        else if (hasChanges && !isNewQuestion)
                        {
                            <div class="sticky-buttons">
                                <ButtonComponent ButtonText="ביטול" ButtonColor="white" TextColor="black" left="70px" Height="40px" OnClick="ResetFields" Width="140px" />
                                <ButtonComponent ButtonText="שמירת שינויים" ButtonColor="orange" TextColor="black" Position="relative" left="70px" Height="40px" Width="140px" />
                            </div>
                        }
                        else
                        {
                            <div class="sticky-buttons">
                                <ButtonComponent ButtonText="ביטול" ButtonColor="white" Width="140px" TextColor="black" left="120px" Height="40px" OnClick="ResetFields" />
                                <ButtonComponent ButtonText="שמירת שינויים" ButtonColor="#EEC383" TextColor="black" Width="140px" left="80px" Disabled="true" />
                            </div>
                        }



                    </EditForm>
                </div>

            </div>
        }




    </div>
}



@code {
    [Parameter]
    public int id { get; set; }

    private EditContext _editContext;
    private string initialQuestionContent;
    private List<AnswerToShow> initialAnswerList;

    bool showModal = false;
    bool showModal2 = false;

    private List<QuestionToShow> questions = new List<QuestionToShow>();
    private List<QuestionToShow> questionToAdd = new List<QuestionToShow>();
    private List<AnswerToShow> answers = new List<AnswerToShow>();
    private bool isLoading = true;
    private string errorMessage;
    private string errorImg;
    private string submitMsg;
    private string imgToShow;
    private string originalTextContent;
    private string originalImageContent;


    private long maxFileSize = 4194304;
    private int? selectedQuestionId = null;
    int minQuestions = 10;
    int maxQuestions = 30;
    private int pendingQuestionId = -1;

    private QuestionToEdit questionsEdit = new QuestionToEdit();
    private QuestionToShow questionsAdd = new QuestionToShow();
    private AnswerToShow answerToEdit = new AnswerToShow();

    private GamesTable gameToEdit = new GamesTable();
    private GamesTable originalGameStats = new GamesTable();
    List<GamesTable> MyGamesList;
    private List<string> tempImagePaths = new List<string>();

    private bool isPhotoChanged = false;
    private bool isNewQuestion = true;
    private bool hasChanges = false;
    private bool isQuestionSelected;
    private bool showModalDeleteQuestion = false;
    private bool showModalDeleteAnswer = false;
    private bool swtichToText = false;
    private bool originalIsImageAnswer = false;
    private bool swtichToImage = false;
    private bool saveIfChanges = false;
    private bool showSaveChangesModal = false;
    private bool showSaveChangesModalForRemove = false;
    private bool largePhotoModalShow = false;
    private string tempGuid;
    private AnswerToShow tempAnswer;
    private bool showToggleConfirmModal = false;
    private bool newValueForToggle;
    private bool editGameChangesConfirmed = false;
    //STARTING CODE SNIPPETS


    private Timer _timer;
    private string _message;
    private bool _showMessage;


    private string originalImage;
    private bool isImageMarkedForDeletion;


    protected override async Task OnInitializedAsync()
    {
        isQuestionSelected = false;
        questionsAdd.id = id;
        await LoadGamesList();
        await LoadQuestions();
        InitializeAnswers();
        GetGameData();
        hasChanges = false;
        initialQuestionContent = questionsEdit.content;
        initialAnswerList = CloneAnswersList(questionsEdit.AnswerList);
        _editContext = new EditContext(questionsEdit);
    }

    protected override void OnInitialized()
    {
        _timer = new Timer(HideMessage, null, Timeout.Infinite, Timeout.Infinite);
    }

    private void ShowMessage(string message)
    {
        _message = message;
        _showMessage = true;
        _timer.Change(2000, Timeout.Infinite); // Show the message for 3 seconds
        StateHasChanged();
    }

    private void HideMessage(object state)
    {
        _showMessage = false;
        _message = string.Empty;
        InvokeAsync(StateHasChanged);
    }
    private List<AnswerToShow> CloneAnswersList(List<AnswerToShow> originalList)
    {
        return originalList.Select(a => new AnswerToShow
            {
                id = a.id,
                questionId = a.questionId,
                textContent = a.textContent,
                imageContentWithoutText = a.imageContentWithoutText,
                IsCorrect = a.IsCorrect,
                IsImageAnswer = a.IsImageAnswer
            }).ToList();
    }

    private bool HasChanges()
    {
        bool isQuestionContentChanged = !string.Equals(initialQuestionContent, questionsEdit.content, StringComparison.Ordinal);
        bool areAnswersChanged = !AreAnswersEqual(initialAnswerList, questionsEdit.AnswerList);
        return isQuestionContentChanged || areAnswersChanged;
    }

    private bool AreAnswersEqual(List<AnswerToShow> initialAnswers, List<AnswerToShow> currentAnswers)
    {
        if (initialAnswers.Count != currentAnswers.Count)
            return false;

        for (int i = 0; i < initialAnswers.Count; i++)
        {
            if (!string.Equals(initialAnswers[i].textContent, currentAnswers[i].textContent, StringComparison.Ordinal) ||
                initialAnswers[i].IsCorrect != currentAnswers[i].IsCorrect ||
                initialAnswers[i].IsImageAnswer != currentAnswers[i].IsImageAnswer ||
                !string.Equals(initialAnswers[i].imageContentWithoutText, currentAnswers[i].imageContentWithoutText, StringComparison.Ordinal))
            {
                return false;
            }
        }
        return true;
    }

    private void MarkChangedStatus()
    {
        hasChanges = HasChanges();
        Console.WriteLine($"Initial Question Content: {initialQuestionContent}");
        Console.WriteLine($"Current Question Content: {questionsEdit.content}");
        Console.WriteLine($"Has Changes: {hasChanges}");
        StateHasChanged();
    }

    private void InitializeAnswers()
    {
        if (questionsEdit.AnswerList == null || !questionsEdit.AnswerList.Any())
        {
            questionsEdit.AnswerList = new List<AnswerToShow>
            {
                new AnswerToShow
                {
                    questionId = questionsEdit.id,
                    textContent = "",
                    IsCorrect = true,
                    IsImageAnswer = false

                },
                new AnswerToShow
                {
                    questionId = questionsEdit.id,
                    textContent = "",
                    IsCorrect = false,
                    IsImageAnswer = false
                }
            };
        }
    }

    private async Task LoadGamesList()
    {
        try
        {
            MyGamesList = await Http.GetFromJsonAsync<List<GamesTable>>("api/games"); // Update the URL to match your API endpoint
            if (MyGamesList == null)
            {
                Console.WriteLine("Failed to load games list.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading games list: {ex.Message}");
        }
    }

    private string GenerateAnswerFileInputId(AnswerToShow answer)
    {
        return $"fileInput_{answer.id}";
    }

    private void GetGameData()
    {
        if (MyGamesList == null)
        {
            Console.WriteLine("MyGamesList is null.");
            return;
        }

        var game = MyGamesList.FirstOrDefault(g => g.ID == id);
        if (game != null)
        {
            gameToEdit = new GamesTable
                {
                    ID = game.ID,
                    GameName = game.GameName,
                    questionTime = game.questionTime
                };

            originalGameStats = new GamesTable
                {
                    ID = game.ID,
                    GameName = game.GameName,
                    questionTime = game.questionTime
                };
            // After assigning the values, print the gameToEdit values
            Console.WriteLine($"ID: {gameToEdit.ID}, GameName: {gameToEdit.GameName}, questionTime: {gameToEdit.questionTime}");
        }
        else
        {
            Console.WriteLine($"Game with ID {id} not found.");
        }
    }

    private async Task LoadQuestions()
    {
        try
        {
            isLoading = true;
            var response = await Http.GetFromJsonAsync<List<QuestionToShow>>($"api/questions/{id}");
            if (response != null)
            {
                questions = response;
                Console.WriteLine($"questions number is: {questions.Count}");

                foreach (var questio in questions)
                {
                    Console.WriteLine($"question image is:{questionsEdit.image}");
                }
            }
            else
            {
                errorMessage = "No questions found.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading questions: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task LoadAnswers(int questionId)
    {
        if (hasChanges)
        {
            if (questionsEdit.id == questionId)
            {
                return;
            }
            else
            {
                showSaveChangesModal = true;
                pendingQuestionId = questionId;

                submitMsg = "";
                StateHasChanged();
                return;
            }

        }

        await LoadAnswersInternal(questionId);
        isQuestionSelected = true;
    }

    private async Task LoadAnswersInternal(int questionId)
    {
        selectedQuestionId = questionId;
        isQuestionSelected = true;


        var selectedQuestion = questions.FirstOrDefault(q => q.id == questionId);
        if (selectedQuestion != null)
        {
            initialQuestionContent = selectedQuestion.content;
            // Fetch answers from the server to ensure the latest data, including images, is retrieved
            var response = await Http.GetFromJsonAsync<List<AnswerToShow>>($"api/questions/answers/{questionId}");

            if (response != null && response.Any())
            {
                questionsEdit = new QuestionToEdit
                    {
                        id = selectedQuestion.id,
                        content = selectedQuestion.content,
                        image = selectedQuestion.image,
                        AnswerList = response.Select(answer => new AnswerToShow
                        {
                            id = answer.id,
                            questionId = answer.questionId,
                            textContent = answer.textContent,
                            imageContentWithoutText = answer.imageContentWithoutText,
                            IsCorrect = answer.IsCorrect,
                            IsImageAnswer = !string.IsNullOrEmpty(answer.imageContentWithoutText) // Set IsImageAnswer based on image content
                        }).ToList()
                    };
            }

            isNewQuestion = false;
            MarkAsUnchanged();
        }
        else
        {
            questionsEdit = new QuestionToEdit(); // Clear the form if no question is selected
        }

        // Update the EditContext
        _editContext = new EditContext(questionsEdit);
    }
    private void HideSaveChangesModal()
    {

        showSaveChangesModal = false;
        pendingQuestionId = -1;
        StateHasChanged();
    }

    private async Task ConfirmLoadAnswers()
    {
        showSaveChangesModal = false;
        if (pendingQuestionId != -1)
        {
            await LoadAnswersInternal(pendingQuestionId);
            pendingQuestionId = -1;
        }
        StateHasChanged();
    }



    private void AddTemporaryAnswer()
    {
        hasChanges = true;
        questionsEdit.AnswerList.Add(new AnswerToShow
            {
                questionId = questionsEdit.id,
                textContent = "",
                IsCorrect = false,
                imageContentWithoutText = null,
                IsImageAnswer = false
            });

        _editContext = new EditContext(questionsEdit); // Update the EditContext
    }

    private async Task EditGame()
    {
        var response = await Http.PutAsJsonAsync($"api/games/settings/{gameToEdit.ID}", gameToEdit);
        if (response.IsSuccessStatusCode)
        {
            await RefreshGameData(); // Fetch the latest data from the server
            editGameChangesConfirmed = true;
            HideModal2();
        }
        else
        {
            var error = await response.Content.ReadAsStringAsync();
            ShowError(error);
        }
        StateHasChanged();
    }

    private async Task RefreshGameData()
    {
        try
        {
            var game = await Http.GetFromJsonAsync<EditGameDTO>($"api/games/{gameToEdit.ID}");
            if (game != null)
            {
                var gameInList = MyGamesList.FirstOrDefault(g => g.ID == gameToEdit.ID);
                if (gameInList != null)
                {
                    gameInList.GameName = game.GameName;
                    gameInList.questionTime = game.questionTime;
                }

                gameToEdit.GameName = game.GameName;
                gameToEdit.questionTime = game.questionTime;

                originalGameStats = new GamesTable
                    {
                        ID = gameToEdit.ID,
                        GameName = game.GameName,
                        questionTime = game.questionTime
                    };
            }
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"HTTP request failed in RefreshGameData: {ex.Message}");
            // Handle the HTTP request exception
        }

        catch (Exception ex)
        {
            Console.WriteLine($"Exception in RefreshGameData: {ex.Message}");
            // Handle other exceptions
        }
    }




    private bool ValidateQuestion(QuestionToEdit question)
    {
        foreach (var answer in question.AnswerList)
        {
            if ((string.IsNullOrWhiteSpace(answer.textContent) || answer.textContent.Length < 2) && string.IsNullOrWhiteSpace(answer.imageContentWithoutText))
            {
                return false;
            }
        }
        return true;
    }

    private async Task CreateQuestion()
    {
        if (ValidateQuestion(questionsEdit))
        {
            try
            {
                // Collect image paths
                if (!string.IsNullOrEmpty(questionsEdit.image))
                {
                    tempImagePaths.Add(Path.GetFileName(questionsEdit.image));
                    Console.WriteLine($"tempImagePaths count: {tempImagePaths.Count}");
                }

                foreach (var answer in questionsEdit.AnswerList)
                {
                    if (!string.IsNullOrEmpty(answer.imageContentWithoutText))
                    {
                        tempImagePaths.Add(Path.GetFileName(answer.imageContentWithoutText));
                        Console.WriteLine($"tempImagePaths count: {tempImagePaths.Count}");
                    }
                }

                // Move images to permanent folder
                if (tempImagePaths.Count > 0)
                {
                    Console.WriteLine("Moving items..");
                    var moveResponse = await Http.PostAsJsonAsync("api/Media/moveFiles", tempImagePaths);
                    if (!moveResponse.IsSuccessStatusCode)
                    {
                        var error = await moveResponse.Content.ReadAsStringAsync();
                        ShowError(error);
                        return;
                    }
                    else
                    {
                        Console.WriteLine("Moved successfully.");

                        // Update the image paths in the questionsEdit object
                        if (!string.IsNullOrEmpty(questionsEdit.image))
                        {
                            questionsEdit.image = $"uploadedFiles/{Path.GetFileName(questionsEdit.image)}";
                        }

                        foreach (var answer in questionsEdit.AnswerList)
                        {
                            if (!string.IsNullOrEmpty(answer.imageContentWithoutText))
                            {
                                answer.imageContentWithoutText = $"uploadedFiles/{Path.GetFileName(answer.imageContentWithoutText)}";
                            }
                        }

                        tempImagePaths.Clear();
                    }
                }

                // Create new question
                questionsEdit.GameId = id;
                var newQuestionRes = await Http.PostAsJsonAsync("api/questions/newQuestion", questionsEdit);
                if (newQuestionRes.IsSuccessStatusCode)
                {
                    QuestionToShow newQuestion = await newQuestionRes.Content.ReadFromJsonAsync<QuestionToShow>();
                    if (newQuestion != null)
                    {
                        submitMsg = "השאלה נשמרה!";
                        ShowMessage(submitMsg); // Show the message for 3 seconds
                        questions.Add(newQuestion);
                        questionsEdit = new QuestionToEdit(); // Clear the form after successful addition
                        isNewQuestion = true;
                        StateHasChanged();
                        answerToEdit.IsImageAnswer = false;
                        isQuestionSelected = false;
                        StateHasChanged();
                        await CheckIfGameCanBePublished();
                        MarkChangedStatus();
                        StateHasChanged();
                        ResetFields();
                    }
                    else
                    {
                        string error = await newQuestionRes.Content.ReadAsStringAsync();
                        ShowError(error);
                    }
                }
                else
                {
                    var error = await newQuestionRes.Content.ReadAsStringAsync();
                    ShowError(error);
                }
            }
            catch (Exception ex)
            {
                ShowError(ex.Message);
            }
        }
        else
        {
            ShowError("Validation failed. Please ensure all answers have either at least 2 characters of text or an image.");
        }
    }





    private async Task CheckIfGameCanBePublished()
    {
        var game = new GamesTable
            {
                ID = gameToEdit.ID,
                CanPublish = gameToEdit.CanPublish,
                isPublished = gameToEdit.isPublished
            };

        var response = await Http.PostAsJsonAsync($"api/games/checkPublish/{gameToEdit.ID}", game);
        if (response.IsSuccessStatusCode)
        {
            var message = await response.Content.ReadAsStringAsync();
            Console.WriteLine(message); // Or update UI to reflect the new publishable state
        }
        else
        {
            var error = await response.Content.ReadAsStringAsync();
            ShowError(error);
        }
    }



    private async Task SaveChanges()
    {
        if (isNewQuestion)
        {
            await CreateQuestion();
        }
        else
        {
            // Collect image paths
            if (!string.IsNullOrEmpty(questionsEdit.image) && questionsEdit.image.Contains("uploadTemp"))
            {
                tempImagePaths.Add(Path.GetFileName(questionsEdit.image));
            }

            foreach (var answer in questionsEdit.AnswerList)
            {
                if (!string.IsNullOrEmpty(answer.imageContentWithoutText) && answer.imageContentWithoutText.Contains("uploadTemp"))
                {
                    tempImagePaths.Add(Path.GetFileName(answer.imageContentWithoutText));
                }
            }

            // Move images to permanent folder before saving changes
            if (tempImagePaths.Count > 0)
            {
                Console.WriteLine("Moving items..");
                var moveResponse = await Http.PostAsJsonAsync("api/Media/moveFiles", tempImagePaths);
                if (!moveResponse.IsSuccessStatusCode)
                {
                    var error = await moveResponse.Content.ReadAsStringAsync();
                    ShowError(error);
                    return;
                }
                else
                {
                    Console.WriteLine("Moved successfully.");

                    // Update the image paths in the questionsEdit object
                    if (!string.IsNullOrEmpty(questionsEdit.image) && questionsEdit.image.Contains("uploadTemp"))
                    {
                        questionsEdit.image = $"uploadedFiles/{Path.GetFileName(questionsEdit.image)}";
                        var updateQuestionImageResponse = await Http.PostAsJsonAsync($"api/questions/updateImagesQuestion/{questionsEdit.id}", questionsEdit.image);
                        if (!updateQuestionImageResponse.IsSuccessStatusCode)
                        {
                            var error = await updateQuestionImageResponse.Content.ReadAsStringAsync();
                            ShowError(error);
                            return;
                        }
                    }

                    foreach (var answer in questionsEdit.AnswerList)
                    {
                        if (!string.IsNullOrEmpty(answer.imageContentWithoutText) && answer.imageContentWithoutText.Contains("uploadTemp"))
                        {
                            answer.imageContentWithoutText = $"uploadedFiles/{Path.GetFileName(answer.imageContentWithoutText)}";
                            var updateAnswerImageResponse = await Http.PostAsJsonAsync($"api/questions/updateImageAnswer/{answer.id}", answer.imageContentWithoutText);
                            if (!updateAnswerImageResponse.IsSuccessStatusCode)
                            {
                                var error = await updateAnswerImageResponse.Content.ReadAsStringAsync();
                                ShowError(error);
                                return;
                            }
                        }
                    }

                    tempImagePaths.Clear();
                }
            }

            // Delete the marked image if SaveChanges is called
            if (isImageMarkedForDeletion == true)
            {
                var deleteResponse = await Http.PostAsJsonAsync("api/Media/deleteImages", new List<string> {(originalImage) });
                if (!deleteResponse.IsSuccessStatusCode)
                {
                    var errorMessage = await deleteResponse.Content.ReadAsStringAsync();
                    errorImg = $"Failed to delete the image: {errorMessage}";
                    return;
                }
            }



            var response = await Http.PutAsJsonAsync($"api/questions/edit-questions/{questionsEdit.id}", questionsEdit);
            if (response.IsSuccessStatusCode)
            {
                var updatedQuestion = questions.FirstOrDefault(q => q.id == questionsEdit.id);
                if (updatedQuestion != null)
                {
                    updatedQuestion.content = questionsEdit.content;
                    updatedQuestion.image = questionsEdit.image;
                    updatedQuestion.AnswerList = questionsEdit.AnswerList;
                    MarkAsUnchanged();
                    await CheckIfGameCanBePublished();
                    submitMsg = "העדכון הושלם!";
                    ShowMessage(submitMsg); 
                    ResetFields();
                    StateHasChanged();
                }
            }
            else
            {
                string error = await response.Content.ReadAsStringAsync();
                ShowError(error);
            }
        }
        isImageMarkedForDeletion = false;
    }





    private void HandleInvalidSubmit()
    {
        _editContext.Validate();
        StateHasChanged();
    }
    private void ConfirmDeleteAnswer(AnswerToShow answer)
    {
        answerToEdit = answer;
        ShowHideModalDeleteAnswer();
    }

    private void DeleteConfirmedAnswer()
    {
        DeleteAnswer(answerToEdit);
        ShowHideModalDeleteAnswer();
    }

    private void DeleteAnswer(AnswerToShow answerToDelete)
    {
        if (answerToDelete.id == 0)
        {
            questionsEdit.AnswerList.Remove(answerToDelete);
            StateHasChanged();
        }
        else
        {
            _ = DeleteAnswerFromServer(answerToDelete);
            MarkChangedStatus();
        }
    }

    private async Task DeleteAnswerFromServer(AnswerToShow answerToDelete)
    {
        if (questionsEdit.AnswerList.Count > 2)
        {
            var response = await Http.DeleteAsync($"api/questions/answers/{answerToDelete.id}");
            if (response.IsSuccessStatusCode)
            {
                questionsEdit.AnswerList.Remove(answerToDelete);
                StateHasChanged();
            }
        }
    }

    private async Task DeleteQuestion()
    {
        try
        {
            var response = await Http.DeleteAsync($"api/questions/{questionsEdit.id}");
            if (response.IsSuccessStatusCode)
            {
                var questionToDelete = questions.FirstOrDefault(q => q.id == questionsEdit.id);
                if (questionToDelete != null)
                {
                    questions.Remove(questionToDelete);
                }
                questionsEdit = new QuestionToEdit();
                InitializeAnswers();
                isNewQuestion = true;
                selectedQuestionId = null;
                isQuestionSelected = false;
                hasChanges = false;
                await CheckIfGameCanBePublished();
                StateHasChanged();
                ShowHideModalDeleteQuestion(); // Hide the delete modal after deletion
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                ShowError(error);
            }
        }
        catch (Exception ex)
        {
            ShowError(ex.Message);
        }
    }



    private void MarkImageForDeletion()
    {
        if (questionsEdit == null || string.IsNullOrEmpty(questionsEdit.image))
        {
            errorImg = "No image to delete.";
            return;
        }

        // Store the original image path
        originalImage = questionsEdit.image;

        // Mark the image for deletion
        isImageMarkedForDeletion = true;

        // Optionally, update the UI to reflect the image is marked for deletion
        questionsEdit.image = ""; // Clear the image in the local object
        hasChanges = true;
        StateHasChanged();
    }

    private void CancelImageDeletion()
    {
        if (isImageMarkedForDeletion)
        {
            // Restore the original image path
            questionsEdit.image = originalImage;
            isImageMarkedForDeletion = false;
            StateHasChanged();
        }
    }

    private async Task DeleteImage()
    {
        if (questionsEdit == null || string.IsNullOrEmpty(questionsEdit.image))
        {
            errorImg = "No image to delete.";
            return;
        }
        //var fileName = Path.GetFileName(questionsEdit.image);
        var deleteResponse = await Http.PostAsJsonAsync("api/Media/deleteImages", new List<string> { questionsEdit.image });
        if (deleteResponse.IsSuccessStatusCode)
        {
            questionsEdit.image = "";
            var updateResponse = await Http.PostAsJsonAsync($"api/questions/updateImagesQuestion/{selectedQuestionId}", questionsEdit.image);

            if (updateResponse.IsSuccessStatusCode)
            {
                errorImg = "Photo has been successfully deleted.";
                StateHasChanged();
            }
            else
            {
                var errorMessage = await updateResponse.Content.ReadAsStringAsync();
                errorImg = $"Failed to update the class image information: {errorMessage}";
            }
        }
        else
        {
            var errorMessage = await deleteResponse.Content.ReadAsStringAsync();
            errorImg = $"Failed to delete the image: {errorMessage}";
        }
    }

    private async Task UploadFile(InputFileChangeEventArgs e)
    {
        var imageFiles = e.GetMultipleFiles();
        foreach (var file in imageFiles)
        {
            if (file.Size <= maxFileSize)
            {
                var buffer = new byte[file.Size];
                await file.OpenReadStream(maxFileSize).ReadAsync(buffer);
                var imageBase64 = Convert.ToBase64String(buffer);

                var saveResponse = await Http.PostAsJsonAsync("api/Media/uploadTemp", imageBase64);
                if (saveResponse.IsSuccessStatusCode)
                {
                    string resizeUrl = await saveResponse.Content.ReadAsStringAsync();
                    questionsEdit.image = "uploadTemp/" + resizeUrl;


                    var saveResponse2 = await Http.PostAsJsonAsync($"api/questions/updateImagesQuestion/{questionsEdit.id}", questionsEdit.image);
                    if (saveResponse2.IsSuccessStatusCode)
                    {
                        errorImg = "The upload was successful.";

                        isPhotoChanged = true;
                        hasChanges = true;
                        StateHasChanged();
                    }
                    else
                    {
                        var errorMessage = await saveResponse2.Content.ReadAsStringAsync();
                        errorImg = $"Image update failed: {errorMessage}";
                    }
                }
                else
                {
                    var errorMessage = await saveResponse.Content.ReadAsStringAsync();
                    errorImg = $"Image upload failed: {errorMessage}";
                }
            }
            else
            {
                errorImg = "File size exceeds the maximum limit.";
            }
        }
    }



    private async Task UploadFileForAnswer(InputFileChangeEventArgs e, AnswerToShow answer)
    {
        var imageFiles = e.GetMultipleFiles();
        foreach (var file in imageFiles)
        {
            if (file.Size <= maxFileSize)
            {
                var buffer = new byte[file.Size];
                await file.OpenReadStream(maxFileSize).ReadAsync(buffer);
                var imageBase64 = Convert.ToBase64String(buffer);

                var saveResponse = await Http.PostAsJsonAsync("api/Media/uploadTemp", imageBase64);
                if (saveResponse.IsSuccessStatusCode)
                {
                    string resizeUrl = await saveResponse.Content.ReadAsStringAsync();
                    answer.imageContentWithoutText = "uploadTemp/" + resizeUrl;



                    var saveResponse2 = await Http.PostAsJsonAsync($"api/questions/updateImagesAnswer/{answer.id}", answer.imageContentWithoutText);
                    if (saveResponse2.IsSuccessStatusCode)
                    {
                        errorImg = "The upload was successful.";

                        isPhotoChanged = true;
                        MarkChangedStatus();
                        StateHasChanged();
                    }
                    else
                    {
                        var errorMessage = await saveResponse2.Content.ReadAsStringAsync();
                        errorImg = $"Image update failed: {errorMessage}";
                    }
                }
                else
                {
                    var errorMessage = await saveResponse.Content.ReadAsStringAsync();
                    errorImg = $"Image upload failed: {errorMessage}";
                }
            }
            else
            {
                errorImg = "File size exceeds the maximum limit.";
            }
        }
    }

   

    private void ShowError(string error)
    {
        switch (error)
        {
            case "No questions found for this game":
                errorMessage = "לא נמצאו שאלות עבור המשחק הזה.";
                break;
            case "Sorry, the question does not exist":
                errorMessage = "מצטערים, השאלה לא קיימת.";
                break;
            case "Sorry, this question has no answers":
                errorMessage = "מצטערים, לשאלה זו אין תשובות.";
                break;
            case "Question not found":
                errorMessage = "השאלה לא נמצאה.";
                break;
            case "Question ID mismatch":
                errorMessage = "חוסר התאמה בין מזהה השאלה.";
                break;
            case "Question content and answers cannot be null":
                submitMsg = "תוכן השאלה ותשובותיה אינם יכולים להיות ריקים.";
                break;
            case "Cannot create more than 30 questions for this game":
                errorMessage = "לא ניתן ליצור יותר מ-30 שאלות למשחק זה.";
                break;
            case "Each answer must have either text content or an image":
                submitMsg = "כל תשובה חייבת לכלול תוכן טקסטואלי או תמונה.";
                break;
            case "Answer content cannot be null":
                submitMsg = "תוכן התשובה אינו יכול להיות ריק.";
                break;
            case "Cannot add more than 6 answers to a question":
                errorMessage = "לא ניתן להוסיף יותר מ-6 תשובות לשאלה.";
                break;
            case "Answer not found":
                errorMessage = "התשובה לא נמצאה.";
                break;
            case "Failed to delete image reference":
                errorMessage = "מחיקת ההתייחסות לתמונה נכשלה.";
                break;
            case "Invalid image path":
                errorMessage = "נתיב תמונה לא תקין.";
                break;
            default:
                errorMessage = "שגיאה לא ידועה.";
                break;
        }
    }

    private void UpdateCheckboxState(AnswerToShow changedAnswer)
    {
        if (changedAnswer.IsCorrect)
        {
            foreach (var answer in questionsEdit.AnswerList)
            {
                if (answer != changedAnswer)
                {
                    answer.IsCorrect = false;
                }
            }
        }
        MarkChangedStatus();
        StateHasChanged();
    }

    private bool IsCheckboxDisabled(AnswerToShow answer)
    {
        return !answer.IsCorrect && questionsEdit.AnswerList.Any(a => a.IsCorrect);
    }

    private void MarkAsChanged()
    {
        hasChanges = true;
        StateHasChanged();
    }

    private void MarkAsUnchanged()
    {
        hasChanges = false;
        StateHasChanged();
    }

    private void ShowModal2()
    {
        showModal2 = true;
    }

    private void HideModal2()
    {
        showModal2 = false;
        if (!editGameChangesConfirmed)
        {
            Console.WriteLine("Getting game data again...");
            GetGameData();
            Console.WriteLine("Received game data...");
        }
        editGameChangesConfirmed = false;
        StateHasChanged();
    }
    private async Task DeleteImageReferenceFromDb(int answerId)
    {
        var response = await Http.PostAsJsonAsync($"api/questions/deleteImageReference/{answerId}", new { ImagePath = answerToEdit.imageContentWithoutText });
        if (response.IsSuccessStatusCode)
        {
            Console.WriteLine("Image reference deleted from database successfully.");
        }
        else
        {
            var errorMessage = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"Failed to delete image reference from database: {errorMessage}");
        }
    }

    private async Task DeletePhotoFromWwwRoot(string imagePath)
    {
        var response = await Http.PostAsJsonAsync("api/Media/deleteImages", new List<string> { imagePath });
        if (!response.IsSuccessStatusCode)
        {
            var errorMessage = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"Failed to delete the image: {errorMessage}");
        }
        else
        {
            Console.WriteLine("Image deleted successfully.");
        }
    }

    private void RemoveSelection()
    {
        if (hasChanges)
        {
            showSaveChangesModalForRemove = true;
            StateHasChanged();
            return;
        }

        PerformRemoveSelection();
    }

    private void PerformRemoveSelection()
    {
        Console.WriteLine("RemoveSelection called.");
        Console.WriteLine($"tempImagePaths count: {tempImagePaths.Count}");

        foreach (var tempImagePath in tempImagePaths)
        {
            Console.WriteLine($"Deleting {tempImagePath}");
            DeletePhotoFromWwwRoot(tempImagePath).Wait();
        }

        // Clear the temporary list after deletion
        tempImagePaths.Clear();

        // Reset questionsEdit
        selectedQuestionId = null;
        isQuestionSelected = false;
        isNewQuestion = true;
        questionsEdit = new QuestionToEdit();
        hasChanges = false;

        questionsEdit.AnswerList = new List<AnswerToShow>
    {
        new AnswerToShow
        {
            questionId = questionsEdit.id,
            textContent = "",
            IsCorrect = false,
            IsImageAnswer = false
        },
        new AnswerToShow
        {
            questionId = questionsEdit.id,
            textContent = "",
            IsCorrect = false,
            IsImageAnswer = false
        }
    };

        StateHasChanged();
    }

    private void HideSaveChangesModalForRemove()
    {
        showSaveChangesModalForRemove = false;
        StateHasChanged();
    }

    private void ConfirmRemoveSelection()
    {
        showSaveChangesModalForRemove = false;
        PerformRemoveSelection();
        StateHasChanged();
    }



    private void ShowHideModalDeleteQuestion()
    {
        showModalDeleteQuestion = !showModalDeleteQuestion;
    }
    private void ShowHideModalDeleteAnswer()
    {
        showModalDeleteAnswer = !showModalDeleteAnswer;
    }

    private void SwitchToTextModal()
    {
        swtichToText = !swtichToText;
    }

    private void SwitchToImageModal()
    {
        swtichToImage = !swtichToImage;
        answerToEdit.IsImageAnswer = true;
        StateHasChanged();
    }
    private void ShowImageModal(string imageUrl)
    {
        imgToShow = imageUrl;
        largePhotoModalShow = true;
        StateHasChanged();
    }

    private void EnlargeImage()
    {
        largePhotoModalShow = !largePhotoModalShow;
        imgToShow = "";
        StateHasChanged();
    }
    private void SwitchToSaveModal()
    {
        if (hasChanges == true)
        {
            saveIfChanges = !saveIfChanges;
            StateHasChanged();
        }
        else
        {
            GoBackToGames();
        }

    }
    






    private bool originalState;

    private async Task ToggleAddType(ChangeEventArgs e, AnswerToShow answer, string guid)
    {
        bool newValue = (bool)e.Value;

        // Check if we need confirmation
        bool needsConfirmation = (newValue && !string.IsNullOrEmpty(answer.textContent)) ||
                                 (!newValue && !string.IsNullOrEmpty(answer.imageContentWithoutText));

        if (needsConfirmation)
        {
            // Store values for confirmation
            originalState = answer.IsImageAnswer;
            newValueForToggle = newValue;
            tempAnswer = answer;
            tempGuid = guid;
            showToggleConfirmModal = true;
            // Revert the checkbox to its original state
            await JS.InvokeVoidAsync("toggleFunctions.setToggleState", guid, originalState);
        }
        else
        {
            // Apply the change immediately
            await ApplyToggleChange(answer, newValue, guid);
        }
    }

    private async Task ApplyToggleChange(AnswerToShow answer, bool newValue, string guid)
    {
        answer.IsImageAnswer = newValue;
        if (newValue)
        {
            answer.textContent = string.Empty;
        }
        else
        {
            if (!string.IsNullOrEmpty(answer.imageContentWithoutText))
            {
                await DeletePhotoFromWwwRoot(answer.imageContentWithoutText);
                await DeleteImageReferenceFromDb(answer.id);
                answer.imageContentWithoutText = string.Empty;
            }
        }
        await JS.InvokeVoidAsync("toggleFunctions.setToggleState", guid, newValue);
        MarkChangedStatus();
        StateHasChanged();
    }

    private async Task ConfirmToggle()
    {
        await ApplyToggleChange(tempAnswer, newValueForToggle, tempGuid);
        showToggleConfirmModal = false;
        StateHasChanged();
    }
    private async Task CancelToggle()
    {
        await JS.InvokeVoidAsync("toggleFunctions.setToggleState", tempGuid, originalState);
        tempAnswer.IsImageAnswer = originalState;
        showToggleConfirmModal = false;
        StateHasChanged();
    }



    void ResetFields()
    {
        questionsEdit = new QuestionToEdit();
        isQuestionSelected = false;
        selectedQuestionId = null;
        hasChanges = false;
        isNewQuestion = true;
        tempImagePaths.Clear();
        InitializeAnswers();
        StateHasChanged();

    }

    void GoBackToGames()
    {
        var baseUri = Nav.BaseUri; 
        var targetUri = $"{baseUri}GamesList"; 

        Nav.NavigateTo(targetUri);
    }


}